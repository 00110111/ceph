#!/bin/bash
# /nightlies/cron_wrapper.sh

# check for no argument case and stop
if [ -z $1 ]; then
  echo "need argument"
  exit 1
fi

# set permanent $LOG file var
# set per-job $LOG_XX file
# set $LOG_LOCKED_ERR in case locking failed
LOG="/var/log/crontab-nightlies-log/crontab.log"
LOG_LOCK_ERR="/var/log/crontab-nightlies-log/crontab_lock_problem.$$"

# temp files to store sdtout and stderr
# named with the PID of this script in their name so they'll be unique
STDERR="/var/tmp/stderr.$$"
STDOUT="/var/tmp/stdout.$$"

# $STDOUT and $STDERR are removed when the script exits for any reason
trap  "rm -f $STDOUT $STDERR" 0

# log a name of the command about to be run
echo "Running command: $@" >> $STDOUT

# run a command from this script's argument
# redirect stdout to $STDOUT file and redirect stderr to $STDERR file
"$@" > $STDOUT 2> $STDERR

# get return code from the command run
code=$?

if [ $code != 0 ] ; then
        # echoing to stdout/stderr makes cron send email
        echo "stdout:"
        cat $STDOUT
        echo "stderr:"
        cat $STDERR
else
        # normal exit: just log stdout
        DATE=$(date)
        echo -n "$DATE: "  >> $STDOUT
        cat $STDOUT   >> $STDOUT
fi

# lock $LOG with file descriptor 200
# if $LOC is locked by other process - wait for 20 sec
# if lock failed, write to $LOG_LOCK_ERR, e.g. all information already in $LOG_XX
exec 200>>$LOG
flock -w 20 200 || LOG=$LOG_LOCK_ERR
# write from per-job $LOG_XX file to the commonn $LOG
cat $LOG_XX >> $LOG
# unlock 
flock -u 200
